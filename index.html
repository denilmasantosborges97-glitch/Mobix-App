<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corrida Cósmica: O Confronto Final</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #000411;
            color: #E0E0E0;
            overflow: hidden;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
            max-width: 450px;
            max-height: 800px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            border: 2px solid #00ffff;
            background-color: #000411;
            overflow: hidden; /* Garante que o tremor de tela não saia do container */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiMwMDA0MTEiPjwvcmVjdD48L3N2Zz4=');
            cursor: none;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(0, 4, 17, 0.8);
            backdrop-filter: blur(5px);
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            z-index: 100;
        }
        .hidden { display: none; }
        .button {
            background: linear-gradient(145deg, #00ffff, #00b8b8);
            border: none; padding: 15px 30px; margin-top: 20px; font-size: 1.5rem; color: #000411;
            font-family: 'Orbitron', sans-serif; cursor: pointer; border-radius: 10px;
            box-shadow: 0 0 15px #00ffff, inset 0 0 5px rgba(255,255,255,0.5);
            transition: all 0.2s ease-in-out;
        }
        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px #00ffff, inset 0 0 10px rgba(255,255,255,0.7);
        }
        .button:disabled, .button:disabled:hover {
            background: linear-gradient(145deg, #5a6b6b, #495c5c); color: #999; cursor: not-allowed;
            box-shadow: none; transform: none;
        }
        h1 { font-size: 3rem; margin-bottom: 10px; }
        p { font-size: 1.2rem; max-width: 80%; }
        #top-bar {
            position: absolute; top: 15px; right: 15px; z-index: 50;
            display: flex; gap: 10px;
        }
        .icon-button {
            background: none; border: 2px solid #00ffff; color: #00ffff;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #mission-container {
            position: absolute; top: 80px; left: 10px; z-index: 40;
            display: flex; flex-direction: column; gap: 5px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px;
            font-size: 0.7rem; max-width: 150px;
        }
        .mission-item { color: #f0f0f0; }
        .mission-progress-bar { height: 4px; background-color: #555; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        .mission-progress { height: 100%; background-color: #00ffff; width: 0%; }
        #boss-health-container {
            position: absolute; top: 120px; left: 5%; width: 90%; z-index: 40;
        }
        #boss-health-bar {
             height: 15px; background-color: #ff3366; width: 100%; border: 2px solid #fff; border-radius: 10px;
             transition: width 0.2s;
        }
    </style>
</head>
<body>
    <audio id="backgroundMusic" loop>
        <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_72092193b2.mp3" type="audio/mpeg">
    </audio>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <!-- HUD -->
        <div id="hud" class="hidden absolute top-0 left-0 right-0 p-3 flex flex-col gap-2" style="pointer-events: none;">
            <div class="flex justify-between items-center text-lg text-cyan-400" style="font-size: 1.5rem; text-shadow: 0 0 5px #00ffff;">
                <div class="flex items-center gap-4">
                    <span id="score">SCORE: 0</span>
                    <div id="lives-container" class="flex items-center gap-1"></div>
                </div>
                <div title="Boost" class="w-24 h-6 bg-gray-900 border-2 border-cyan-400 rounded-full overflow-hidden" style="pointer-events: auto;">
                    <div id="boost-bar" class="h-full bg-cyan-400" style="width: 100%;"></div>
                </div>
                <span id="dust">DUST: 0</span>
            </div>
            <div id="xp-bar-container" class="w-full h-3 bg-gray-900/50 border border-purple-500 rounded-full">
                <div id="xp-bar" class="h-full bg-purple-500 rounded-full transition-all duration-300" style="width: 0%;"></div>
            </div>
        </div>
        <!-- Botões do Topo -->
        <div id="top-bar">
            <button id="pauseButton" class="icon-button hidden">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
            </button>
            <button id="muteButton" class="icon-button">
                <svg id="soundOnIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                <svg id="soundOffIcon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
            </button>
        </div>
        <!-- UI Elementos -->
        <div id="mission-container" class="hidden"></div>
        <div id="boss-health-container" class="hidden">
            <div id="boss-health-bar"></div>
        </div>
        
        <!-- Menus Overlay -->
        <div id="startMenu" class="ui-overlay">
            <h1>Corrida Cósmica</h1>
            <p>Toque para mover, desvie dos perigos e deslize para cima para usar o impulso!</p>
            <button id="startButton" class="button">INICIAR</button>
            <button id="shopButton" class="button" style="font-size: 1.2rem; padding: 10px 20px;">LOJA</button>
        </div>
        <div id="pauseMenu" class="ui-overlay hidden">
            <h1>PAUSADO</h1>
            <button id="resumeButton" class="button">CONTINUAR</button>
            <button id="quitButton" class="button" style="background: linear-gradient(145deg, #c44, #a22); font-size: 1.2rem; padding: 10px 20px;">SAIR</button>
        </div>
        <div id="gameOverMenu" class="ui-overlay hidden">
            <div id="finalStats">
                <h1>FIM DE JOGO</h1>
                <p>Pontuação Final: <span id="finalScore">0</span></p>
                <p>Poeira Coletada: <span id="finalDust">0</span></p>
            </div>
            <div id="extraLifeContainer" class="hidden">
                 <h1>UMA CHANCE EXTRA?</h1>
                 <p>Assista a um anúncio para ganhar +1 vida e continuar sua corrida!</p>
                 <button id="watchAdButton" class="button">Assistir Anúncio (+1 Vida)</button>
                 <button id="noThanksButton" class="button" style="font-size: 1rem; padding: 8px 16px; background: linear-gradient(145deg, #5a6b6b, #495c5c);">Não, obrigado</button>
            </div>
            <button id="restartButton" class="button">JOGAR NOVAMENTE</button>
        </div>
        <div id="shopMenu" class="ui-overlay hidden" style="justify-content: flex-start; padding-top: 20px;">
            <h1 style="font-size: 2.5rem;">LOJA DE NAVES</h1>
            <p class="mb-4">Total de Poeira: <span id="totalDustDisplay">0</span></p>
            <div id="ship-grid" class="grid grid-cols-2 gap-4 overflow-y-auto p-4 w-full h-3/4"></div>
            <button id="backButton" class="button" style="font-size: 1.2rem; padding: 10px 20px;">VOLTAR</button>
        </div>
        <div id="levelUpMenu" class="ui-overlay hidden">
             <h1>LEVEL UP!</h1>
             <p>Escolha um aprimoramento:</p>
             <div id="upgrade-options" class="flex flex-col mt-4 space-y-3"></div>
        </div>
         <div id="creditsMenu" class="ui-overlay hidden">
            <h1 style="font-size: 2.5rem;">VITÓRIA!</h1>
            <p>Você derrotou a frota inimiga! Parabéns!</p>
            <p style="font-size: 1.5rem; margin-top: 40px;">CRÉDITOS</p>
            <p style="font-size: 1.2rem;">Criador: Weslley Fernando Barros Santos</p>
            <p style="font-size: 1rem; margin-bottom: 20px;">Meu primeiro jogo criado</p>
            <button id="mainMenuButton" class="button">MENU PRINCIPAL</button>
        </div>
    </div>

    <script>
        // --- Configurações Iniciais ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('score');
        const dustDisplay = document.getElementById('dust');
        const startMenu = document.getElementById('startMenu');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const finalStats = document.getElementById('finalStats');
        const extraLifeContainer = document.getElementById('extraLifeContainer');
        const watchAdButton = document.getElementById('watchAdButton');
        const noThanksButton = document.getElementById('noThanksButton');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalDustDisplay = document.getElementById('finalDust');
        const shopButton = document.getElementById('shopButton');
        const shopMenu = document.getElementById('shopMenu');
        const backButton = document.getElementById('backButton');
        const totalDustDisplay = document.getElementById('totalDustDisplay');
        const shipGrid = document.getElementById('ship-grid');
        const levelUpMenu = document.getElementById('levelUpMenu');
        const upgradeOptionsContainer = document.getElementById('upgrade-options');
        const livesContainer = document.getElementById('lives-container');
        const muteButton = document.getElementById('muteButton');
        const soundOnIcon = document.getElementById('soundOnIcon');
        const soundOffIcon = document.getElementById('soundOffIcon');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const pauseButton = document.getElementById('pauseButton');
        const pauseMenu = document.getElementById('pauseMenu');
        const resumeButton = document.getElementById('resumeButton');
        const quitButton = document.getElementById('quitButton');
        const missionContainer = document.getElementById('mission-container');
        const bossHealthContainer = document.getElementById('boss-health-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const mainMenuButton = document.getElementById('mainMenuButton');

        let canvasWidth, canvasHeight;
        let gameState = 'menu';
        let player, obstacles, starDusts, gravityWells, stars, particles, powerUps, projectiles, xpOrbs, explosions, enemyProjectiles, boss;
        let score, dust, scoreInterval;
        let animationFrameId;
        let difficultyMultiplier;
        let worldSpeedMultiplier;
        let screenFlash = { alpha: 0 };
        let screenShake = { duration: 0, magnitude: 0 };
        let hasUsedExtraLife = false;
        let totalDust = 0;
        let unlockedShips = ['default'];
        let selectedShip = 'default';
        let bossesDefeated = 0;
        const BOSS_SCORES = [5000, 12000, 20000, 30000, 45000];
        let nextBossScore;
        const BOOST_MAX_ENERGY = 100;
        const BOOST_COST = 40;
        const BOOST_RECHARGE_RATE = 0.4;
        const BOOST_SPEED_MULTIPLIER = 3;
        let isBoosting = false;
        let boostTimer = 0;

        // --- Gerenciador de Som ---
        const soundManager = {
            isMuted: false, sounds: {},
            loadSounds: function() {
                this.sounds.shoot = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_1082306385.mp3');
                this.sounds.explosion = new Audio('https://cdn.pixabay.com/download/audio/2021/08/04/audio_12b0c347f3.mp3');
                this.sounds.damage = new Audio('https://cdn.pixabay.com/download/audio/2022/03/23/audio_3c7f07275d.mp3');
                this.sounds.powerup = new Audio('https://cdn.pixabay.com/download/audio/2022/01/21/audio_ea20392812.mp3');
                this.sounds.levelUp = new Audio('https://cdn.pixabay.com/download/audio/2022/05/26/audio_adfdef4c24.mp3');
                this.sounds.gameOver = new Audio('https://cdn.pixabay.com/download/audio/2023/04/23/audio_409139294e.mp3');
                this.sounds.missionComplete = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_29170a7532.mp3');
                this.sounds.bossSpawn = new Audio('https://cdn.pixabay.com/download/audio/2022/08/25/audio_511915a769.mp3');
                Object.values(this.sounds).forEach(s => s.volume = 0.5);
                this.sounds.shoot.volume = 0.3;
            },
            play: function(soundName) {
                if (this.isMuted || !this.sounds[soundName]) return;
                const sound = this.sounds[soundName].cloneNode();
                sound.volume = this.sounds[soundName].volume;
                sound.play().catch(error => {});
            },
            toggleMute: function() {
                this.isMuted = !this.isMuted; backgroundMusic.muted = this.isMuted;
                if (!this.isMuted && (gameState === 'playing' || gameState === 'paused')) { backgroundMusic.play().catch(e => {}); } else { backgroundMusic.pause(); }
                soundOnIcon.classList.toggle('hidden', this.isMuted); soundOffIcon.classList.toggle('hidden', !this.isMuted);
            }
        };
        
        // --- Missões ---
        const allMissions = [ { id: 'destroy_asteroids', description: 'Destrua 25 asteroides', target: 25, type: 'destroy_asteroid' }, { id: 'destroy_ships', description: 'Destrua 10 naves inimigas', target: 10, type: 'destroy_ship' }, { id: 'collect_dust', description: 'Colete 200 de poeira', target: 200, type: 'collect_dust' }, { id: 'survive_score', description: 'Alcance 3000 pontos', target: 3000, type: 'reach_score' }, { id: 'use_boost', description: 'Use o impulso 5 vezes', target: 5, type: 'use_boost' } ];
        let activeMissions = []; let completedMissions = [];
        const missionsManager = {
            init: function() { const available = allMissions.filter(m => !completedMissions.includes(m.id)); activeMissions = []; for (let i = 0; i < 3 && available.length > 0; i++) { const missionIndex = Math.floor(Math.random() * available.length); const mission = { ...available.splice(missionIndex, 1)[0], progress: 0 }; activeMissions.push(mission); } this.updateDisplay(); },
            updateProgress: function(type, amount = 1) { activeMissions.forEach(mission => { if (mission.type === type && mission.progress < mission.target) { mission.progress = Math.min(mission.target, mission.progress + amount); if (mission.progress >= mission.target) this.completeMission(mission); } else if (mission.type === 'reach_score') { mission.progress = Math.min(mission.target, score); if (mission.progress >= mission.target) this.completeMission(mission); } }); this.updateDisplay(); },
            completeMission: function(mission) { if (completedMissions.includes(mission.id)) return; soundManager.play('missionComplete'); const reward = 100 + Math.floor(mission.target * 2.5); dust += reward; totalDust += reward; completedMissions.push(mission.id); saveGameData(); },
            updateDisplay: function() { missionContainer.innerHTML = ''; activeMissions.forEach(mission => { const isComplete = mission.progress >= mission.target; const item = document.createElement('div'); item.className = 'mission-item'; item.innerHTML = `<span>${mission.description} ${isComplete ? '✓' : ''}</span><div class="mission-progress-bar"><div class="mission-progress" style="width: ${Math.min(100, (mission.progress / mission.target) * 100)}%;"></div></div>`; if (isComplete) item.style.color = '#00ffaa'; missionContainer.appendChild(item); }); }
        };

        const SHIPS = { 'default': { name: 'Padrão', price: 0, draw: function(ctx, x, y, width, height, color) { const w2 = width / 2; ctx.beginPath(); ctx.moveTo(x + w2, y); ctx.lineTo(x, y + height * 0.85); ctx.lineTo(x + w2, y + height); ctx.lineTo(x + width, y + height * 0.85); ctx.closePath(); ctx.fillStyle = color; ctx.fill(); ctx.beginPath(); ctx.arc(x + w2, y + height * 0.3, width * 0.15, 0, Math.PI * 2); ctx.fillStyle = '#222'; ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke(); ctx.fillStyle = `rgba(255, 255, 100, ${0.7 + Math.random() * 0.3})`; ctx.beginPath(); ctx.moveTo(x + w2 - 5, y + height); ctx.lineTo(x + w2, y + height + 15); ctx.lineTo(x + w2 + 5, y + height); ctx.closePath(); ctx.fill(); }}, 'interceptor': { name: 'Interceptor', price: 500, draw: function(ctx, x, y, width, height, color) { const w2 = width / 2; ctx.beginPath(); ctx.moveTo(x + w2, y); ctx.lineTo(x + w2 - width * 0.15, y + height); ctx.lineTo(x + w2 + width * 0.15, y + height); ctx.closePath(); ctx.fillStyle = color; ctx.fill(); ctx.beginPath(); ctx.moveTo(x, y + height * 0.6); ctx.lineTo(x + width, y + height * 0.6); ctx.lineTo(x + w2, y + height * 0.5); ctx.closePath(); ctx.fillStyle = '#00cc00'; ctx.fill(); ctx.fillStyle = `rgba(150, 255, 150, ${0.7 + Math.random() * 0.3})`; ctx.beginPath(); ctx.moveTo(x + w2 - 3, y + height); ctx.lineTo(x + w2, y + height + 20); ctx.lineTo(x + w2 + 3, y + height); ctx.closePath(); ctx.fill(); }}, 'bomber': { name: 'Bombardeiro', price: 1200, draw: function(ctx, x, y, width, height, color) { ctx.beginPath(); ctx.rect(x + width * 0.1, y + height * 0.1, width * 0.8, height * 0.9); ctx.fillStyle = color; ctx.fill(); ctx.beginPath(); ctx.rect(x, y + height * 0.4, width, height * 0.3); ctx.fillStyle = '#cc6600'; ctx.fill(); ctx.beginPath(); ctx.rect(x + width * 0.3, y, width * 0.4, height * 0.2); ctx.fillStyle = '#ffcc88'; ctx.fill(); ctx.fillStyle = `rgba(255, 150, 50, ${0.7 + Math.random() * 0.3})`; ctx.fillRect(x + width * 0.1, y + height, width * 0.2, 10); ctx.fillRect(x + width * 0.7, y + height, width * 0.2, 10); }}, 'scout': { name: 'Batedor', price: 2500, draw: function(ctx, x, y, width, height, color) { const w2 = width / 2; ctx.beginPath(); ctx.moveTo(x, y + height * 0.2); ctx.lineTo(x + width, y + height); ctx.moveTo(x + width, y + height * 0.2); ctx.lineTo(x, y + height); ctx.strokeStyle = color; ctx.lineWidth = width * 0.2; ctx.stroke(); ctx.beginPath(); ctx.ellipse(x + w2, y + height * 0.6, width * 0.2, height * 0.5, 0, 0, Math.PI * 2); ctx.fillStyle = '#cccc00'; ctx.fill(); ctx.fillStyle = `rgba(255, 255, 150, ${0.7 + Math.random() * 0.3})`; ctx.beginPath(); ctx.moveTo(x + w2 - 4, y + height); ctx.lineTo(x + w2, y + height + 12); ctx.lineTo(x + w2 + 4, y + height); ctx.closePath(); ctx.fill(); }} };
        const UPGRADES = { 'fireRate': { name: 'Cadência +20%', apply: (player) => player.weapon.fireRate *= 0.8 }, 'projectileSpeed': { name: 'Velocidade Projétil +25%', apply: (player) => player.weapon.projectileSpeed *= 1.25 }, 'multiShot': { name: 'Tiro Múltiplo', maxLevel: 10, isUnique: false, apply: (player) => player.weapon.multiShotLevel++ }, 'homingMissile': { name: 'Míssil Teleguiado', maxLevel: 5, isUnique: false, apply: (player) => player.weapon.homingLevel++ }, 'grenadeLauncher': { name: 'Lança-Granadas', maxLevel: 5, isUnique: false, apply: (player) => player.weapon.grenadeLevel++ }, 'sideCannons': { name: 'Canhões Laterais', maxLevel: 5, isUnique: false, apply: (player) => player.weapon.sideCannonLevel++ }, 'laserBeam': { name: 'Raio Laser', isUnique: true, apply: (player) => player.weapon.hasLaser = true }, 'boostRecharge': { name: 'Recarga Impulso +30%', apply: (player) => player.boostRechargeRate *= 1.3 }, 'healthUp': { name: 'Vida Extra', isUnique: true, apply: (player) => { player.lives++; updateLivesDisplay(); } }, 'xpGain': { name: 'Ganho de XP +25%', apply: (player) => player.xpMultiplier *= 1.25 }, 'dustGain': { name: 'Coleta de Poeira +20%', apply: (player) => player.dustMultiplier *= 1.2 }, 'piercingShot': { name: 'Tiro Perfurante', maxLevel: 5, isUnique: false, apply: (player) => player.weapon.pierceLevel++ }, 'orbitalDrone': { name: 'Drone Orbital', maxLevel: 3, isUnique: false, apply: (player) => player.addDrone() } };
        let availableUpgrades = [];

        // --- Classes do Jogo ---
        class Player { constructor() { this.width = 30; this.height = 45; this.x = canvasWidth / 2 - this.width / 2; this.y = canvasHeight - this.height - 20; this.speed = 7; this.dx = 0; this.color = '#00ffff'; this.shipDesign = SHIPS[selectedShip]; this.weapon = { fireRate: 30, projectileSpeed: 7, multiShotLevel: 1, homingLevel: 0, grenadeLevel: 0, sideCannonLevel: 0, grenadeCooldown: 0, sideCannonCooldown: 0, hasLaser: false, laserCooldown: 0, pierceLevel: 0 }; this.fireCooldown = 0; this.homingFireCounter = 0; this.lives = 3; this.isInvincible = false; this.invincibilityTimer = 0; this.level = 1; this.xp = 0; this.xpToNextLevel = 100; this.boostRechargeRate = BOOST_RECHARGE_RATE; this.isShielded = false; this.shieldTimer = 0; this.isMagnetActive = false; this.magnetTimer = 0; this.boostEnergy = BOOST_MAX_ENERGY; this.xpMultiplier = 1; this.dustMultiplier = 1; this.drones = []; } addDrone() { this.drones.push(new Drone(this, this.drones.length)); } draw() { if (this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return; this.drones.forEach(d => d.draw()); ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; this.shipDesign.draw(ctx, this.x, this.y, this.width, this.height, this.color); if (this.isShielded) { ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.8, 0, Math.PI * 2); ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.random() * 0.5})`; ctx.lineWidth = 3; ctx.stroke(); } ctx.shadowBlur = 0; } update(targetX) { this.dx = (targetX - (this.x + this.width / 2)) * 0.15; this.x += this.dx; if (this.x < 0) this.x = 0; if (this.x + this.width > canvasWidth) this.x = canvasWidth - this.width; if (this.y < 0) this.y = 0; if (this.y + this.height > canvasHeight) this.y = canvasHeight - this.height; if (this.isInvincible) { this.invincibilityTimer--; if (this.invincibilityTimer <= 0) this.isInvincible = false; } if (this.isShielded) { this.shieldTimer--; if (this.shieldTimer <= 0) this.isShielded = false; } if (this.isMagnetActive) { this.magnetTimer--; if (this.magnetTimer <= 0) this.isMagnetActive = false; } if (this.boostEnergy < BOOST_MAX_ENERGY) this.boostEnergy += this.boostRechargeRate; if (this.weapon.grenadeCooldown > 0) this.weapon.grenadeCooldown--; if (this.weapon.sideCannonCooldown > 0) this.weapon.sideCannonCooldown--; if (this.weapon.laserCooldown > 0) this.weapon.laserCooldown--; if (this.weapon.grenadeLevel > 0 && this.weapon.grenadeCooldown <= 0) this.launchGrenades(); if (this.weapon.sideCannonLevel > 0 && this.weapon.sideCannonCooldown <= 0) this.fireSideCannons(); this.fireCooldown--; if (this.fireCooldown <= 0) { this.shoot(); this.fireCooldown = this.weapon.fireRate; } updateBoostBar(); this.drones.forEach(d => d.update()); } shoot() { const projX = this.x + this.width / 2; const projY = this.y; if (this.weapon.hasLaser && this.weapon.laserCooldown <= 0) { projectiles.push(new LaserBeam(projX, 0, 0, '#ff1111')); this.weapon.laserCooldown = 240; soundManager.play('shoot'); } if (this.weapon.homingLevel > 0) { this.homingFireCounter++; if (this.homingFireCounter >= 120 - (this.weapon.homingLevel * 10)) { for (let i = 0; i < this.weapon.homingLevel; i++) { projectiles.push(new HomingProjectile(projX, projY, this.weapon.projectileSpeed * 0.8, '#ff69b4')); } soundManager.play('shoot'); this.homingFireCounter = 0; } } const count = this.weapon.multiShotLevel; const spacing = 12; for (let i = 0; i < count; i++) { const startX = projX - (spacing * (count - 1) / 2); projectiles.push(new Projectile(startX + i * spacing, projY, this.weapon.projectileSpeed, '#00ffff')); } soundManager.play('shoot'); } fireSideCannons() { const projY = this.y + this.height / 2; projectiles.push(new SideProjectile(this.x, projY, -this.weapon.projectileSpeed)); projectiles.push(new SideProjectile(this.x + this.width, projY, this.weapon.projectileSpeed)); soundManager.play('shoot'); this.weapon.sideCannonCooldown = Math.max(20, 100 - (this.weapon.sideCannonLevel * 15)); } launchGrenades() { const numGrenades = 8; for (let i = 0; i < numGrenades; i++) { const angle = (i / numGrenades) * Math.PI * 2; projectiles.push(new Grenade(this.x + this.width / 2, this.y + this.height / 2, angle)); } soundManager.play('shoot'); const baseCooldown = 600; const maxReduction = 300; this.weapon.grenadeCooldown = baseCooldown - (maxReduction * ((this.weapon.grenadeLevel - 1) / 9)); } takeDamage() { if (this.isInvincible || this.isShielded) return; this.lives--; updateLivesDisplay(); soundManager.play('damage'); triggerScreenShake(15, 5); if (this.lives <= 0) { gameOver(); } else { this.isInvincible = true; this.invincibilityTimer = 120; createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ff4f4f', 30); } } activateShield(duration) { this.isShielded = true; this.shieldTimer = duration; } activateMagnet(duration) { this.isMagnetActive = true; this.magnetTimer = duration; } useBoost() { if (this.boostEnergy >= BOOST_COST) { this.boostEnergy -= BOOST_COST; missionsManager.updateProgress('use_boost'); return true; } return false; } }
        class Drone { constructor(player, index) { this.player = player; this.angle = (index / 3) * Math.PI * 2; this.radius = 6; this.orbitRadius = 50; this.x = 0; this.y = 0; this.fireCooldown = 90; } update() { this.angle += 0.03; this.x = this.player.x + this.player.width / 2 + Math.cos(this.angle) * this.orbitRadius; this.y = this.player.y + this.player.height / 2 + Math.sin(this.angle) * this.orbitRadius; this.fireCooldown--; if (this.fireCooldown <= 0) { projectiles.push(new Projectile(this.x, this.y, 5, '#aaffaa')); this.fireCooldown = 90; } } draw() { ctx.fillStyle = '#aaffaa'; ctx.shadowBlur = 8; ctx.shadowColor = '#aaffaa'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; } }
        class Projectile { constructor(x, y, speed, color) { this.x = x; this.y = y; this.width = 4; this.height = 15; this.speed = speed; this.color = color; this.pierce = 1 + (player ? player.weapon.pierceLevel : 0); } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 5; ctx.shadowColor = this.color; ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height); ctx.shadowBlur = 0; } update() { this.y -= this.speed; } }
        class EnemyProjectile extends Projectile { constructor(x, y, speed, color) { super(x, y, speed, color); } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 8; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; } update() { this.y += this.speed * worldSpeedMultiplier; } }
        class AngledEnemyProjectile extends EnemyProjectile { constructor(x, y, vx, vy, color) { super(x, y, 0, color); this.vx = vx; this.vy = vy; } update() { this.x += this.vx; this.y += this.vy * worldSpeedMultiplier; } }
        class HomingEnemyProjectile extends EnemyProjectile { constructor(x, y, speed, color) { super(x, y, speed, color); this.turnSpeed = 0.04; this.angle = Math.PI/2; } update() { if(player) { const targetAngle = Math.atan2(player.y + player.height/2 - this.y, player.x + player.width/2 - this.x); let angleDiff = targetAngle - this.angle; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; if (Math.abs(angleDiff) > this.turnSpeed) { this.angle += this.turnSpeed * Math.sign(angleDiff); } else { this.angle = targetAngle; } } this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed * worldSpeedMultiplier; } }
        class BossLaser extends EnemyProjectile { constructor(y) { super(canvasWidth/2, y, 0, 'rgba(255, 50, 50, 0.7)'); this.width = canvasWidth; this.height = 20; this.life = 30; this.radius = 1000; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000'; ctx.fillRect(0, this.y - this.height/2, this.width, this.height); ctx.shadowBlur=0;} update() { this.life--; } }
        class SideProjectile extends Projectile { constructor(x, y, speed) { super(x, y, 0, '#f0ad4e'); this.vx = speed; this.width = 15; this.height = 4; } update() { this.x += this.vx; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 5; ctx.shadowColor = this.color; ctx.fillRect(this.x, this.y - this.height / 2, this.width, this.height); ctx.shadowBlur = 0; } }
        class HomingProjectile extends Projectile { constructor(x, y, speed, color) { super(x, y, speed, color); this.target = null; this.turnSpeed = 0.08; this.height = 15; this.width = 8; this.angle = -Math.PI / 2; } findTarget() { let closestDist = Infinity; let closestObstacle = null; const combinedTargets = [...obstacles, boss].filter(Boolean); for (const obstacle of combinedTargets) { if (obstacle.y > 0 && obstacle.y < canvasHeight) { let centerX = obstacle.x + (obstacle.width || 0) / 2; let centerY = obstacle.y + (obstacle.height || 0) / 2; const dist = Math.hypot(this.x - centerX, this.y - centerY); if (dist < closestDist) { closestDist = dist; closestObstacle = obstacle; } } } this.target = closestObstacle; } update() { if (!this.target || this.target.y > canvasHeight + (this.target.radius || 0) || this.target.health <= 0) { this.findTarget(); } if (this.target) { let targetX = this.target.x + (this.target.width || 0) / 2; let targetY = this.target.y + (this.target.height || 0) / 2; const targetAngle = Math.atan2(targetY - this.y, targetX - this.x); let angleDiff = targetAngle - this.angle; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; if (Math.abs(angleDiff) > this.turnSpeed) { this.angle += this.turnSpeed * Math.sign(angleDiff); } else { this.angle = targetAngle; } } this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle + Math.PI / 2); ctx.fillStyle = `rgba(255, 105, 180, 0.5)`; ctx.beginPath(); ctx.moveTo(0, this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2 + 10); ctx.lineTo(this.width / 2, this.height / 2 + 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 12; ctx.shadowColor = '#ff69b4'; ctx.beginPath(); ctx.moveTo(0, -this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.lineTo(this.width / 2, this.height / 2); ctx.closePath(); ctx.fill(); ctx.restore(); } }
        class LaserBeam extends Projectile { constructor(x, y, speed, color) { super(x, y, speed, color); this.width = 10; this.height = canvasHeight; this.life = 15; } draw() { ctx.save(); ctx.globalAlpha = Math.min(1, this.life / 5); ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height); ctx.restore(); } update() { this.y = 0; this.life--; } }
        class Grenade extends Projectile { constructor(x, y, angle) { super(x, y, 4, '#33ff33'); this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.life = 40; } update() { this.x += this.vx; this.y += this.vy; this.life--; if (this.life <= 0) { explosions.push(new Explosion(this.x, this.y, 80)); soundManager.play('explosion'); projectiles.splice(projectiles.indexOf(this), 1); } } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 8; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; } }
        class Obstacle { constructor() { this.radius = Math.random() * 25 + 15; this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius; this.y = -this.radius * 2; this.speed = Math.min(10, (Math.random() * 1.5 + 1.5) * difficultyMultiplier); this.color = `rgb(${100+Math.random()*50}, ${80+Math.random()*40}, ${60+Math.random()*30})`; this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = (Math.random() - 0.5) * 0.02; this.shape = []; const sides = Math.floor(Math.random() * 5 + 7); for (let i = 0; i < sides; i++) { const angle = (i / sides) * Math.PI * 2; const radius = this.radius * (Math.random() * 0.4 + 0.8); this.shape.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius }); } } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = '#555'; ctx.beginPath(); ctx.moveTo(this.shape[0].x, this.shape[0].y); for (let i = 1; i < this.shape.length; i++) { ctx.lineTo(this.shape[i].x, this.shape[i].y); } ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); } update() { this.y += this.speed * worldSpeedMultiplier * (isBoosting ? BOOST_SPEED_MULTIPLIER : 1); this.rotation += this.rotationSpeed; } }
        class EnemyShip { constructor() { this.width = 30; this.height = 30; this.x = Math.random() < 0.5 ? -this.width : canvasWidth; this.y = Math.random() * (canvasHeight / 2); this.speed = Math.min(12, (Math.random() * 2 + 3) * difficultyMultiplier); this.color = '#ff3366'; this.vx = (this.x < 0 ? this.speed / 3 : -this.speed / 3) * (0.5 + Math.random()); this.vy = this.speed / 2; this.radius = 15; this.type = 'ship'; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y); ctx.lineTo(this.x, this.y + this.height * 0.75); ctx.lineTo(this.x + this.width / 2, this.y + this.height); ctx.lineTo(this.x + this.width, this.y + this.height * 0.75); ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0; } update() { this.x += this.vx; this.y += this.vy * worldSpeedMultiplier; } }
        class EnemyShooter extends EnemyShip { constructor() { super(); this.color = '#f0ad4e'; this.vy = 1; this.fireCooldown = 120; } update() { super.update(); this.fireCooldown--; if (this.fireCooldown <= 0 && this.y > 0 && this.y < canvasHeight) { enemyProjectiles.push(new EnemyProjectile(this.x + this.width / 2, this.y + this.height, 4, '#ff8c00')); this.fireCooldown = 120 + Math.random() * 60; soundManager.play('shoot'); } } }
        class EnemyScout extends EnemyShip { constructor() { super(); this.color = '#ffff00'; this.width = 25; this.height = 25; this.speed = Math.min(14, (Math.random() * 3 + 4) * difficultyMultiplier); this.vx = (this.x < 0 ? this.speed / 2 : -this.speed / 2); this.vy = this.speed / 2; this.waveAmplitude = Math.random() * 40 + 20; this.waveFrequency = Math.random() * 0.05 + 0.02; this.initialX = this.x; } update() { this.initialX += this.vx; this.x = this.initialX + Math.sin(this.y * this.waveFrequency) * this.waveAmplitude; this.y += this.vy * worldSpeedMultiplier; } }
        class EnemyBrute extends EnemyShip { constructor() { super(); this.color = '#cccccc'; this.width = 50; this.height = 50; this.radius = 25; this.speed = Math.min(6, (Math.random() * 1 + 1) * difficultyMultiplier); this.vx = 0; this.vy = this.speed; this.health = 3; this.x = Math.random() * (canvasWidth - this.width); this.y = -this.height; } takeDamage() { this.health--; if (this.health <= 0) return true; this.color = '#ff9999'; setTimeout(() => this.color = '#cccccc', 100); return false; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.shadowBlur = 0; } }
        class Boss { constructor() { this.level = bossesDefeated; this.width = 150 + this.level * 10; this.height = 100 + this.level * 5; this.x = canvasWidth / 2 - this.width / 2; this.y = -this.height; this.maxHealth = (500 + 350 * this.level) * (1 + (player.level / 5)); this.health = this.maxHealth; this.state = 'entering'; this.stateTimer = 0; this.color = '#ff1493'; this.radius = this.width/2; this.type = 'boss'; this.currentAttackPattern = 0; this.laserWarning = false; this.laserCharge = 0; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 20; ctx.shadowColor = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 20, this.y + 20, 20, 20); ctx.fillRect(this.x + this.width - 40, this.y + 20, 20, 20); if(this.laserWarning && this.laserCharge > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${Math.sin(Date.now()/100)})`; ctx.fillRect(0, this.laserY - 2, canvasWidth, 4); } ctx.shadowBlur = 0; } update() { this.stateTimer--; switch (this.state) { case 'entering': this.y += 1; if (this.y >= 50) { this.state = 'firing'; this.stateTimer = 240; } break; case 'firing': this.attack(); if (this.stateTimer <= 0) { this.state = 'waiting'; this.stateTimer = Math.max(60, 120 - this.level * 10); } break; case 'waiting': if (this.stateTimer <= 0) { this.state = 'firing'; this.stateTimer = 240; } break; } } attack() { if (this.level === 4) { if (this.stateTimer % 90 === 0) { this.currentAttackPattern = Math.floor(Math.random() * 5); } this.executeAttack(this.currentAttackPattern); } else { this.executeAttack(this.level); } } executeAttack(pattern) { const scaledPlayerLevel = player ? player.level : 1; switch (pattern) { case 0: if (this.stateTimer % Math.max(10, 30 - this.level * 4 - scaledPlayerLevel) === 0) { const cannonX = this.x + (Math.random() * this.width); enemyProjectiles.push(new EnemyProjectile(cannonX, this.y + this.height, 5 + this.level, '#ff1493')); soundManager.play('shoot'); } break; case 1: if (this.stateTimer % Math.max(20, 60 - this.level * 8 - scaledPlayerLevel) === 0) { for (let i = -this.level -2; i <= this.level+2; i++) { if (i === 0) continue; const angle = i * 0.15; const speed = 4; const vy = Math.cos(angle) * speed; const vx = Math.sin(angle) * speed; enemyProjectiles.push(new AngledEnemyProjectile(this.x + this.width / 2, this.y + this.height, vx, vy, '#ff944d')); } soundManager.play('shoot'); } break; case 2: if (this.level > 1 && this.stateTimer % Math.max(40, 100 - this.level * 15 - scaledPlayerLevel) === 0) { enemyProjectiles.push(new HomingEnemyProjectile(this.x + this.width / 2, this.y + this.height, 3 + this.level*0.5, '#cc00cc')); soundManager.play('shoot'); } break; case 3: if (this.level > 2 && this.stateTimer % Math.max(80, 150 - this.level * 20 - scaledPlayerLevel) === 0) { obstacles.push(new EnemyShip()); obstacles.push(new EnemyShooter()); } break; case 4: if (!this.laserWarning) { this.laserWarning = true; this.laserY = player.y; this.laserCharge = 90; } if (this.laserCharge > 0) { this.laserCharge--; } else { enemyProjectiles.push(new BossLaser(this.laserY)); this.laserWarning = false; this.currentAttackPattern = Math.floor(Math.random() * 4); } break; } } takeDamage(amount) { this.health -= amount; bossHealthBar.style.width = `${(this.health / this.maxHealth) * 100}%`; if (this.health <= 0) this.die(); } die() { createParticles(this.x + this.width / 2, this.y + this.height / 2, this.color, 200); score += 1000 * (this.level + 1); dust += 250 * (this.level + 1); for (let i = 0; i < 10; i++) xpOrbs.push(new XpOrb(this.x + Math.random() * this.width, this.y + Math.random() * this.height)); bossesDefeated++; if (bossesDefeated >= BOSS_SCORES.length) { gameWon(); return; } nextBossScore = BOSS_SCORES[bossesDefeated]; boss = null; bossHealthContainer.classList.add('hidden'); soundManager.play('explosion'); } }
        class StarDust { constructor() { this.radius = 5; this.x = Math.random() * canvasWidth; this.y = -this.radius; this.speed = Math.random() * 1.5 + 1; this.color = '#ffff00'; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill(); ctx.shadowBlur = 0; } update() { this.y += this.speed * worldSpeedMultiplier * (isBoosting ? BOOST_SPEED_MULTIPLIER : 1); if (player && player.isMagnetActive) { const dist = Math.hypot(player.x + player.width / 2 - this.x, player.y + player.height / 2 - this.y); if (dist < canvasWidth / 2.5) { const angle = Math.atan2(player.y + player.height / 2 - this.y, player.x + player.width / 2 - this.x); this.x += Math.cos(angle) * 6; this.y += Math.sin(angle) * 6; } } } }
        class GravityWell { constructor() { this.radius = Math.random() * 20 + 30; this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius; this.y = -this.radius; this.speed = 1.5; this.influenceRadius = this.radius * 5; this.strength = 3; this.color = 'rgba(150, 50, 255, 0.7)'; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowBlur = 20; ctx.shadowColor = '#9632ff'; ctx.fill(); ctx.beginPath(); ctx.arc(this.x, this.y, this.influenceRadius, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(150, 50, 255, 0.2)'; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0; } update() { this.y += this.speed * worldSpeedMultiplier * (isBoosting ? BOOST_SPEED_MULTIPLIER : 1); } }
        class Star { constructor() { this.x = Math.random() * canvasWidth; this.y = Math.random() * canvasHeight; this.radius = Math.random() * 1.5; this.speed = Math.random() * 0.5 + 0.2; this.alpha = Math.random(); } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(224, 224, 224, ${this.alpha})`; ctx.fill(); } update() { this.y += this.speed * worldSpeedMultiplier * (isBoosting ? BOOST_SPEED_MULTIPLIER : 1); if(this.y > canvasHeight) { this.y = 0; this.x = Math.random() * canvasWidth; } } }
        class PowerUp { constructor() { this.radius = 15; this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius; this.y = -this.radius; this.speed = 2.5; const rand = Math.random(); if (rand < 0.08) { this.type = 'bomb'; } else if (rand < 0.54) { this.type = 'shield'; } else { this.type = 'magnet'; } } draw() { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); let color, bgColor, icon; if (this.type === 'shield') { color = '#00ffff'; bgColor = 'rgba(0, 255, 255, 0.5)'; icon = 'S'; } else if (this.type === 'magnet') { color = '#ff00ff'; bgColor = 'rgba(255, 0, 255, 0.5)'; icon = 'M'; } else { color = '#ff4f4f'; bgColor = 'rgba(255, 79, 79, 0.5)'; icon = 'B'; } ctx.fillStyle = bgColor; ctx.strokeStyle = color; ctx.shadowColor = color; ctx.fill(); ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 15; ctx.fillStyle = color; ctx.font = 'bold 18px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(icon, this.x, this.y + 1); ctx.restore(); } update() { this.y += this.speed * worldSpeedMultiplier * (isBoosting ? BOOST_SPEED_MULTIPLIER : 1); } }
        class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.radius = Math.random() * 3 + 1; this.speed = Math.random() * 4 + 1; this.angle = Math.random() * Math.PI * 2; this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed; this.life = 50; this.alpha = 1; } draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); ctx.restore(); } update() { this.x += this.vx; this.y += this.vy; this.vy += 0.05; this.life--; this.alpha = this.life / 50; } }
        class Explosion { constructor(x, y, maxRadius) { this.x = x; this.y = y; this.radius = 10; this.maxRadius = maxRadius; this.life = 20; } update() { this.radius += (this.maxRadius - this.radius) * 0.1; this.life--; } draw() { ctx.fillStyle = `rgba(255, 100, 0, ${this.life / 20 * 0.8})`; ctx.strokeStyle = `rgba(255, 255, 0, ${this.life / 20})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } }
        class XpOrb { constructor(x, y) { this.x = x; this.y = y; this.radius = 6; this.speed = 2; this.value = 20; this.color = '#9632ff'; } draw() { ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; } update() { this.y += this.speed * worldSpeedMultiplier; if (player && player.isMagnetActive) { const dist = Math.hypot(player.x + player.width / 2 - this.x, player.y + player.height / 2 - this.y); if (dist < canvasWidth / 2.5) { const angle = Math.atan2(player.y + player.height / 2 - this.y, player.x + player.width / 2 - this.x); this.x += Math.cos(angle) * 6; this.y += Math.sin(angle) * 6; } } } }

        // --- Funções do Jogo ---
        function triggerScreenShake(duration, magnitude) { screenShake = { duration, magnitude }; }
        function createParticles(x, y, color, count = 20) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color)); } }
        function activateDevastatorBomb() { screenFlash = { alpha: 0.8 }; soundManager.play('explosion'); obstacles.forEach(obs => { createParticles(obs.x, obs.y, obs.color, 15); score += 5; dust += 2; }); obstacles.length = 0; scoreDisplay.textContent = `SCORE: ${score}`; dustDisplay.textContent = `DUST: ${dust}`; }
        function init() { const rect = gameContainer.getBoundingClientRect(); canvasWidth = canvas.width = rect.width; canvasHeight = canvas.height = rect.height; player = new Player(); obstacles = []; starDusts = []; gravityWells = []; particles = []; powerUps = []; projectiles = []; xpOrbs = []; stars = []; explosions = []; enemyProjectiles = []; boss = null; bossHealthContainer.classList.add('hidden'); difficultyMultiplier = 1; worldSpeedMultiplier = 1.0; hasUsedExtraLife = false; bossesDefeated = 0; nextBossScore = BOSS_SCORES[0]; for(let i = 0; i < 100; i++) stars.push(new Star()); score = 0; dust = 0; scoreDisplay.textContent = `SCORE: 0`; dustDisplay.textContent = `DUST: 0`; updateXpBar(); updateLivesDisplay(); targetPlayerX = canvasWidth / 2; missionsManager.init(); }
        function startGame() { init(); gameState = 'playing'; startMenu.classList.add('hidden'); gameOverMenu.classList.add('hidden'); document.getElementById('creditsMenu').classList.add('hidden'); shopMenu.classList.add('hidden'); levelUpMenu.classList.add('hidden'); hud.classList.remove('hidden'); pauseButton.classList.remove('hidden'); missionContainer.classList.remove('hidden'); if (!soundManager.isMuted) { backgroundMusic.currentTime = 0; backgroundMusic.play().catch(e => {}); } availableUpgrades = Object.keys(UPGRADES); scoreInterval = setInterval(() => { if(gameState === 'playing') { score++; scoreDisplay.textContent = `SCORE: ${score}`; missionsManager.updateProgress('reach_score'); } }, 100); if (animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); }
        function showFinalGameOver() { finalStats.classList.remove('hidden'); extraLifeContainer.classList.add('hidden'); restartButton.classList.remove('hidden'); totalDust += dust; saveGameData(); finalScoreDisplay.textContent = score; finalDustDisplay.textContent = dust; soundManager.play('gameOver'); }
        function gameOver() { gameState = 'gameOver'; isBoosting = false; clearInterval(scoreInterval); backgroundMusic.pause(); cancelAnimationFrame(animationFrameId); gameOverMenu.classList.remove('hidden'); hud.classList.add('hidden'); pauseButton.classList.add('hidden'); missionContainer.classList.add('hidden'); bossHealthContainer.classList.add('hidden'); if (hasUsedExtraLife) { showFinalGameOver(); } else { finalStats.classList.add('hidden'); extraLifeContainer.classList.remove('hidden'); restartButton.classList.add('hidden'); } }
        function gameWon() { gameState = 'won'; isBoosting = false; clearInterval(scoreInterval); backgroundMusic.pause(); cancelAnimationFrame(animationFrameId); hud.classList.add('hidden'); document.getElementById('creditsMenu').classList.remove('hidden'); }
        function togglePause() { if (gameState === 'paused') { gameState = 'playing'; pauseMenu.classList.add('hidden'); if (!soundManager.isMuted) backgroundMusic.play(); gameLoop(); } else if (gameState === 'playing') { gameState = 'paused'; backgroundMusic.pause(); pauseMenu.classList.remove('hidden'); } }
        function handleSpawning() { if(boss) return; if (Math.random() < 0.04) obstacles.push(new Obstacle()); if (bossesDefeated >= 1 && Math.random() < 0.008 * difficultyMultiplier) { obstacles.push(new EnemyShip()); } if (bossesDefeated >= 2 && Math.random() < 0.005 * difficultyMultiplier) { obstacles.push(new EnemyShooter()); } if (bossesDefeated >= 3 && Math.random() < 0.006 * difficultyMultiplier) { obstacles.push(new EnemyScout()); } if (bossesDefeated >= 4 && Math.random() < 0.004 * difficultyMultiplier) { obstacles.push(new EnemyBrute()); } if (Math.random() < 0.05) starDusts.push(new StarDust()); if (Math.random() < 0.003) gravityWells.push(new GravityWell()); if (Math.random() < 0.006) powerUps.push(new PowerUp()); }
        function handleCollisions() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i]; if (!projectile) continue;
                const combinedTargets = [...obstacles, boss].filter(Boolean); let hit = false;
                for (let j = combinedTargets.length - 1; j >= 0; j--) {
                    const target = combinedTargets[j];
                    const dist = Math.hypot(projectile.x - (target.x + (target.width || 0) / 2), projectile.y - (target.y + (target.height || 0) / 2));
                    if (dist < target.radius) {
                        if (target.type === 'boss') { target.takeDamage(10); } 
                        else {
                            if (target instanceof EnemyBrute && !target.takeDamage()) { /* Brute was hit but not destroyed */ } 
                            else {
                                createParticles(target.x + (target.width || 0) / 2, target.y + (target.height || 0) / 2, target.color);
                                if (Math.random() < 0.5) xpOrbs.push(new XpOrb(target.x, target.y));
                                missionsManager.updateProgress(target.type === 'ship' ? 'destroy_ship' : 'destroy_asteroid');
                                obstacles.splice(j, 1); score += 10; dust += 1;
                            }
                        }
                        projectile.pierce--;
                        if (projectile.pierce <= 0 && !(projectile instanceof LaserBeam)) { projectiles.splice(i, 1); hit = true; }
                        soundManager.play('explosion'); break;
                    }
                }
                if(hit) continue;
            }
            const allHazards = [...obstacles, ...enemyProjectiles, boss].filter(Boolean);
            for (let i = allHazards.length - 1; i >= 0; i--) { const hazard = allHazards[i]; const dist = Math.hypot((player.x + player.width / 2) - (hazard.x + (hazard.width || 0) / 2), (player.y + player.height / 2) - (hazard.y + (hazard.height || 0) / 2)); if (dist < hazard.radius + player.width / 2.5) { player.takeDamage(); if (gameState !== 'gameOver') { if (hazard instanceof EnemyProjectile) { enemyProjectiles.splice(i, 1); } else if (hazard.type !== 'boss') { obstacles.splice(i, 1); } createParticles(hazard.x, hazard.y, hazard.color, 10); soundManager.play('explosion'); } } }
            for (let i = starDusts.length - 1; i >= 0; i--) { const starDust = starDusts[i]; if (player.x < starDust.x + starDust.radius && player.x + player.width > starDust.x - starDust.radius && player.y < starDust.y + starDust.radius && player.y + player.height > starDust.y - starDust.radius) { const dustGained = Math.floor(5 * player.dustMultiplier); dust += dustGained; missionsManager.updateProgress('collect_dust', dustGained); createParticles(starDust.x, starDust.y, '#ffff00', 5); starDusts.splice(i, 1); soundManager.play('powerup'); } }
            for (let i = powerUps.length - 1; i >= 0; i--) { const powerUp = powerUps[i]; const dist = Math.hypot(player.x + player.width / 2 - powerUp.x, player.y + player.height / 2 - powerUp.y); if (dist < player.width / 2 + powerUp.radius) { soundManager.play('powerup'); if (powerUp.type === 'shield') { player.activateShield(300); createParticles(powerUp.x, powerUp.y, '#00ffff'); } else if (powerUp.type === 'magnet') { player.activateMagnet(480); createParticles(powerUp.x, powerUp.y, '#ff00ff'); } else if (powerUp.type === 'bomb') { activateDevastatorBomb(); createParticles(powerUp.x, powerUp.y, '#ff4f4f');} powerUps.splice(i, 1); } }
            for (let i = xpOrbs.length - 1; i >= 0; i--) { const orb = xpOrbs[i]; const dist = Math.hypot(player.x + player.width / 2 - orb.x, player.y + player.height / 2 - orb.y); if (dist < player.width / 2 + orb.radius) { gainXp(orb.value); createParticles(orb.x, orb.y, orb.color, 3); xpOrbs.splice(i, 1); soundManager.play('powerup'); } }
            for (let i = explosions.length - 1; i >= 0; i--) { const explosion = explosions[i]; for (let j = obstacles.length - 1; j >= 0; j--) { const obstacle = obstacles[j]; const dist = Math.hypot(explosion.x - obstacle.x, explosion.y - obstacle.y); if (dist < explosion.radius + obstacle.radius) { createParticles(obstacle.x, obstacle.y, obstacle.color); missionsManager.updateProgress(obstacle.type === 'ship' ? 'destroy_ship' : 'destroy_asteroid'); obstacles.splice(j, 1); score += 10; dust += 1; } } }
            scoreDisplay.textContent = `SCORE: ${score}`; dustDisplay.textContent = `DUST: ${dust}`;
        }
        function update() {
            difficultyMultiplier = 1 + (score / 10000) + ((player.level - 1) * 0.08);
            player.update(targetPlayerX);
            if(boss) boss.update();
            else if(score >= nextBossScore && bossesDefeated < BOSS_SCORES.length) { boss = new Boss(); bossHealthContainer.classList.remove('hidden'); bossHealthBar.style.width = '100%'; soundManager.play('bossSpawn'); triggerScreenShake(30, 8); }
            stars.forEach(s => s.update());
            particles.forEach((p, index) => { p.update(); if (p.life <= 0) particles.splice(index, 1); });
            [projectiles, enemyProjectiles].forEach(arr => arr.forEach((p, index) => { if (p.y + p.height < 0 || p.y > canvasHeight || p.x < 0 || p.x > canvasWidth || (p.life && p.life <= 0)) { arr.splice(index, 1); } else { p.update(); } }));
            [obstacles, starDusts, gravityWells, powerUps, xpOrbs].forEach(arr => { arr.forEach((item, index) => { item.update(); if (item.y > canvasHeight + 100 || item.x < -100 || item.x > canvasWidth + 100) arr.splice(index, 1); }); });
            explosions.forEach((exp, index) => { exp.update(); if (exp.life <= 0) explosions.splice(index, 1); });
            handleSpawning(); handleCollisions();
        }
        function draw() { ctx.save(); ctx.clearRect(0, 0, canvasWidth, canvasHeight); if(screenShake.duration > 0) { const dx = (Math.random() - 0.5) * screenShake.magnitude; const dy = (Math.random() - 0.5) * screenShake.magnitude; ctx.translate(dx, dy); screenShake.duration--; } stars.forEach(s => s.draw()); [obstacles, starDusts, gravityWells, powerUps, xpOrbs, enemyProjectiles].forEach(arr => arr.forEach(item => item.draw())); if(boss) boss.draw(); projectiles.forEach(p => p.draw()); player.draw(); particles.forEach(p => p.draw()); explosions.forEach(exp => exp.draw()); if (screenFlash.alpha > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash.alpha})`; ctx.fillRect(0, 0, canvasWidth, canvasHeight); screenFlash.alpha -= 0.04; } ctx.restore(); }
        function gameLoop() { if (gameState !== 'playing') return; update(); draw(); if (isBoosting) { boostTimer--; if(boostTimer <= 0) isBoosting = false; } animationFrameId = requestAnimationFrame(gameLoop); }
        function updateBoostBar() { const boostBar = document.getElementById('boost-bar'); if(boostBar && player) boostBar.style.width = `${(player.boostEnergy / BOOST_MAX_ENERGY) * 100}%`; }
        function updateXpBar() { const xpBar = document.getElementById('xp-bar'); if(xpBar && player) xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`; }
        function updateLivesDisplay() { if (!livesContainer || !player) return; livesContainer.innerHTML = ''; for (let i = 0; i < player.lives; i++) { const heartIcon = document.createElement('div'); heartIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4f4f" style="filter: drop-shadow(0 0 3px #ff4f4f);"><path fill-rule="evenodd" d="M8 1.314C12.438-3.248 23.534 4.735 8 15-7.534 4.736 3.562-3.248 8 1.314z"/></svg>`; livesContainer.appendChild(heartIcon); } }
        function gainXp(amount) { if (!player) return; player.xp += (amount * player.xpMultiplier); if (player.xp >= player.xpToNextLevel) levelUp(); updateXpBar(); }
        function levelUp() { gameState = 'levelUp'; clearInterval(scoreInterval); player.level++; player.xp -= player.xpToNextLevel; player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5); soundManager.play('levelUp'); populateUpgradeOptions(); levelUpMenu.classList.remove('hidden'); updateXpBar(); }
        function populateUpgradeOptions() { upgradeOptionsContainer.innerHTML = ''; let chosenUpgrades = []; let tempUpgrades = [...availableUpgrades].filter(id => { const upgrade = UPGRADES[id]; if (!upgrade.maxLevel) return true; let currentLevel = 0; if(id === 'multiShot') currentLevel = player.weapon.multiShotLevel; else if(id === 'homingMissile') currentLevel = player.weapon.homingLevel; else if(id === 'grenadeLauncher') currentLevel = player.weapon.grenadeLevel; else if(id === 'sideCannons') currentLevel = player.weapon.sideCannonLevel; else if(id === 'piercingShot') currentLevel = player.weapon.pierceLevel; else if(id === 'orbitalDrone') currentLevel = player.drones.length; return currentLevel < upgrade.maxLevel; }); for (let i = 0; i < 3 && tempUpgrades.length > 0; i++) { const randomIndex = Math.floor(Math.random() * tempUpgrades.length); chosenUpgrades.push(tempUpgrades.splice(randomIndex, 1)[0]); } chosenUpgrades.forEach(upgradeId => { const upgrade = UPGRADES[upgradeId]; const button = document.createElement('button'); button.className = 'button'; let text = upgrade.name; if (!upgrade.isUnique) { let currentLevel = 0; if(upgradeId === 'multiShot') currentLevel = player.weapon.multiShotLevel - 1; else if(upgradeId === 'homingMissile') currentLevel = player.weapon.homingLevel; else if(upgradeId === 'grenadeLauncher') currentLevel = player.weapon.grenadeLevel; else if(upgradeId === 'sideCannons') currentLevel = player.weapon.sideCannonLevel; else if(upgradeId === 'piercingShot') currentLevel = player.weapon.pierceLevel; else if(upgradeId === 'orbitalDrone') currentLevel = player.drones.length; text = `${upgrade.name} Nv. ${currentLevel + 1}`; } button.textContent = text; button.onclick = () => selectUpgrade(upgradeId); upgradeOptionsContainer.appendChild(button); }); }
        function selectUpgrade(upgradeId) { const upgrade = UPGRADES[upgradeId]; upgrade.apply(player); if (upgrade.isUnique && !upgrade.maxLevel) { const index = availableUpgrades.indexOf(upgradeId); if (index > -1) availableUpgrades.splice(index, 1); } levelUpMenu.classList.add('hidden'); gameState = 'playing'; scoreInterval = setInterval(() => { if(gameState === 'playing') { score++; scoreDisplay.textContent = `SCORE: ${score}`; missionsManager.updateProgress('reach_score');}}, 100); gameLoop(); }
        function saveGameData() { localStorage.setItem('cosmicRaceData', JSON.stringify({ totalDust: totalDust, unlockedShips: unlockedShips, selectedShip: selectedShip, completedMissions: completedMissions })); }
        function loadGameData() { const savedData = localStorage.getItem('cosmicRaceData'); if (savedData) { const gameData = JSON.parse(savedData); totalDust = gameData.totalDust || 0; unlockedShips = gameData.unlockedShips || ['default']; selectedShip = gameData.selectedShip || 'default'; completedMissions = gameData.completedMissions || []; } }
        function openShop() { gameState = 'shop'; startMenu.classList.add('hidden'); shopMenu.classList.remove('hidden'); pauseButton.classList.add('hidden'); muteButton.classList.add('hidden'); populateShop(); }
        function closeShop() { gameState = 'menu'; shopMenu.classList.add('hidden'); startMenu.classList.remove('hidden'); pauseButton.classList.remove('hidden'); muteButton.classList.remove('hidden'); }
        function populateShop() { shipGrid.innerHTML = ''; totalDustDisplay.textContent = Math.floor(totalDust); for (const shipId in SHIPS) { const ship = SHIPS[shipId]; const isUnlocked = unlockedShips.includes(shipId); const isSelected = selectedShip === shipId; const shipCard = document.createElement('div'); shipCard.className = 'border-2 rounded-lg p-2 flex flex-col items-center justify-between'; shipCard.style.borderColor = isSelected ? '#ffff00' : '#00ffff'; let buttonHtml; if (isSelected) buttonHtml = `<button class="w-full mt-2 p-1 rounded bg-yellow-500 text-black text-sm font-bold" disabled>EQUIPADO</button>`; else if (isUnlocked) buttonHtml = `<button class="w-full mt-2 p-1 rounded bg-cyan-400 text-black text-sm font-bold" onclick="selectShip('${shipId}')">SELECIONAR</button>`; else buttonHtml = `<button class="w-full mt-2 p-1 rounded ${totalDust >= ship.price ? 'bg-green-500' : 'bg-gray-600'} text-black text-sm font-bold" onclick="buyShip('${shipId}')">${ship.price} Poeira</button>`; shipCard.innerHTML = `<p class="text-sm">${ship.name}</p><canvas width="80" height="80"></canvas>${buttonHtml}`; shipGrid.appendChild(shipCard); const previewCanvas = shipCard.querySelector('canvas'); const previewCtx = previewCanvas.getContext('2d'); previewCtx.clearRect(0, 0, 80, 80); ship.draw(previewCtx, 25, 20, 30, 45, '#00ffff'); } }
        function buyShip(shipId) { const ship = SHIPS[shipId]; if (totalDust >= ship.price && !unlockedShips.includes(shipId)) { totalDust -= ship.price; unlockedShips.push(shipId); selectShip(shipId); saveGameData(); populateShop(); } }
        function selectShip(shipId) { if (unlockedShips.includes(shipId)) { selectedShip = shipId; saveGameData(); populateShop(); } }
        let targetPlayerX; let touchStartY = 0;
        function getEventX(e) { const rect = canvas.getBoundingClientRect(); if (e.touches && e.touches.length > 0) return e.touches[0].clientX - rect.left; return e.clientX - rect.left; }
        function handleMove(e) { if (gameState === 'playing' && player) targetPlayerX = getEventX(e); }
        
        // --- Event Listeners ---
        window.addEventListener('resize', init);
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', openShop);
        backButton.addEventListener('click', closeShop);
        muteButton.addEventListener('click', () => soundManager.toggleMute());
        pauseButton.addEventListener('click', togglePause);
        resumeButton.addEventListener('click', togglePause);
        quitButton.addEventListener('click', () => { location.reload(); });
        mainMenuButton.addEventListener('click', () => { location.reload(); });
        noThanksButton.addEventListener('click', showFinalGameOver);
        watchAdButton.addEventListener('click', () => {
            console.log("Exibindo anúncio simulado...");
            hasUsedExtraLife = true; player.lives = 1; updateLivesDisplay();
            obstacles = obstacles.filter(obs => Math.hypot(player.x - obs.x, player.y - obs.y) > canvasWidth / 3);
            gameOverMenu.classList.add('hidden'); hud.classList.remove('hidden'); pauseButton.classList.remove('hidden'); missionContainer.classList.remove('hidden'); gameState = 'playing';
            if(!soundManager.isMuted) backgroundMusic.play();
            scoreInterval = setInterval(() => { if(gameState === 'playing') {score++; scoreDisplay.textContent = `SCORE: ${score}`; missionsManager.updateProgress('reach_score');}}, 100); gameLoop();
        });
        canvas.addEventListener('mousedown', (e) => handleMove(e));
        canvas.addEventListener('mousemove', (e) => { if (e.buttons === 1) handleMove(e); });
        canvas.addEventListener('touchstart', (e) => { touchStartY = e.touches[0].clientY; handleMove(e); }, { passive: true });
        canvas.addEventListener('touchmove', (e) => handleMove(e), { passive: true });
        canvas.addEventListener('touchend', (e) => { if (!player) return; const touchEndY = e.changedTouches[0].clientY; if (touchStartY - touchEndY > 50) { if (player.useBoost()) { isBoosting = true; boostTimer = 60; createParticles(player.x + player.width/2, player.y + player.height, '#ffffff'); } } });

        loadGameData();
        soundManager.loadSounds();
        init();
    </script>
</body>
</html>

